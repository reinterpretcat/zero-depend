use super::*;
use std::ops::Add;

impl<T, const N: usize> Tensor<T, N> {
    /// Creates a new tensor with the specified data and shape.
    /// Returns an error if the data size does not match the shape.
    pub fn new(data: Vec<T>, shape: &[usize]) -> Result<Self> {
        let size: usize = shape.iter().product();
        if size != data.len() {
            return Err(TensorError::ShapeMismatch(format!(
                "Data size {} does not match shape size {}",
                data.len(),
                size
            )));
        }
        let strides = Self::compute_strides(&shape);
        let shape = shape.iter().copied().collect();

        Ok(Self {
            data: Arc::new(data),
            shape,
            strides,
            offset: 0,
        })
    }

    /// Creates a new tensor with a range of values from 0 to `end`.
    /// The values are generated by incrementing from 0 by 1.
    /// Returns an error if `end` is less than 0.
    pub fn arange(end: T) -> Result<Tensor<T, N>>
    where
        T: Clone + Default + PartialOrd + Add<Output = T> + From<bool>,
    {
        if end < T::default() {
            return Err(TensorError::IndexOutOfBounds(
                "End must be greater than or equal to zero".to_string(),
            ));
        }

        let mut data = Vec::new();
        let mut val = T::default();
        while val < end {
            data.push(val.clone());
            val = val + T::from(true);
        }

        let shape = small_vec![data.len()];

        Ok(Tensor {
            data: Arc::new(data),
            shape,
            strides: small_vec![1],
            offset: 0,
        })
    }

    /// Creates a new tensor filled with zeros of the specified shape.
    pub fn zeros(shape: Vec<usize>) -> Tensor<T, N>
    where
        T: Default + Clone,
    {
        let total_size = shape.iter().product();
        let data = vec![T::default(); total_size];
        let strides = Self::compute_strides(&shape);
        let shape = shape.iter().copied().collect();

        Tensor {
            data: Arc::new(data),
            shape,
            strides,
            offset: 0,
        }
    }

    /// Creates a new tensor filled with ones of the specified shape.
    pub fn ones(shape: &[usize]) -> Tensor<T, N>
    where
        T: From<i32> + Clone,
    {
        let total_size = shape.iter().product();
        let data = vec![T::from(1); total_size];
        let strides = Self::compute_strides(&shape);
        let shape = shape.iter().copied().collect();

        Tensor {
            data: Arc::new(data),
            shape,
            strides,
            offset: 0,
        }
    }

    /// Computes the strides for a tensor given its shape.
    /// Strides in [Tensor] implementation represent how many elements you need to skip in the underlying
    /// data vector to move by one index along each dimension of the tensor.
    /// Each stride is the product of all sizes of the dimensions after it.
    /// # Example
    /// Suppose shape = [2, 3, 4]:
    /// Start: strides = [1, 1, 1]
    /// Iteration:
    /// * i = 1: strides[1] = strides[2] * shape[2] = 1 * 4 = 4 → [1, 4, 1]
    /// * i = 0: strides[0] = strides[1] * shape[1] = 4 * 3 = 12 → [12, 4, 1]
    /// So, for a 3D tensor:
    /// * To move along the first dimension, jump 12 elements.
    /// * To move along the second, jump 4 elements.
    /// * To move along the third, jump 1 element.
    pub(crate) fn compute_strides(shape: &[usize]) -> SmallVec<usize, N> {
        let mut strides = small_vec![1; shape.len()];
        for i in (0..shape.len().saturating_sub(1)).rev() {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        strides
    }
}

impl<T, const N: usize> From<Vec<T>> for Tensor<T, N> {
    fn from(data: Vec<T>) -> Self {
        let len = data.len();
        Tensor {
            data: Arc::new(data),
            shape: small_vec![len],
            strides: small_vec![1],
            offset: 0,
        }
    }
}

impl<T, const N: usize, const D: usize> TryFrom<Vec<[T; D]>> for Tensor<T, N> {
    type Error = TensorError;

    fn try_from(data: Vec<[T; D]>) -> Result<Self> {
        if data.is_empty() {
            return Err(TensorError::ShapeMismatch("Empty 2D vector".to_string()));
        }

        let rows = data.len();
        let cols = data[0].len();

        let flat_data: Vec<T> = data.into_iter().flatten().collect();
        let shape = small_vec![rows, cols];
        let strides = Self::compute_strides(&shape);

        Ok(Tensor {
            data: Arc::new(flat_data),
            shape,
            strides,
            offset: 0,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arange() -> Result<()> {
        let tensor = Tensor::<i32>::arange(5)?;
        assert_eq!(tensor.shape(), &[5]);
        assert_eq!(*tensor.get(&[0])?, 0);
        assert_eq!(*tensor.get(&[4])?, 4);

        Ok(())
    }

    #[test]
    fn test_arange_f32() -> Result<()> {
        let tensor = Tensor::<f32>::arange(5_f32)?;
        assert_eq!(tensor.shape(), &[5]);
        assert_eq!(*tensor.get(&[0])?, 0.);
        assert_eq!(*tensor.get(&[4])?, 4.);

        Ok(())
    }

    #[test]
    fn test_strides() {
        let shape = vec![3, 4];
        let strides = Tensor::<i32>::compute_strides(&shape);
        assert_eq!(strides, small_vec![4, 1]);

        let shape = vec![2, 3, 4];
        let strides = Tensor::<i32>::compute_strides(&shape);
        assert_eq!(strides, small_vec![12, 4, 1]);
    }
}
